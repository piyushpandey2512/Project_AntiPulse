#include "PrimaryGenerator.hh"
#include "G4Event.hh"
#include <random>
#include "GeoConstruction.hh"
#include "G4RunManager.hh"

// Add these as class members in PrimaryGenerator.hh or as static/global for quick testing
bool useThreeSourceCone = false;
bool useSingleSourceX = false;
bool useSingleSourceIsotropic = false;
bool useMoireSource = true;

MyPrimaryParticles::MyPrimaryParticles()
{
    fParticleGun = new G4ParticleGun(1);
}

MyPrimaryParticles::~MyPrimaryParticles()
{
    delete fParticleGun;
}

void MyPrimaryParticles::GeneratePrimaries(G4Event* anEvent)
{
    G4cout << "[PrimaryGenerator] Generating event: " << anEvent->GetEventID() << G4endl;

    // Define the particle type
    G4ParticleTable* particleTable = G4ParticleTable::GetParticleTable();
    G4ParticleDefinition* piPlus = particleTable->FindParticle("pi+");
    G4ParticleDefinition* antiProton = particleTable->FindParticle("anti_proton");
    fParticleGun->SetParticleDefinition(piPlus);
    // fParticleGun->SetParticleDefinition(antiProton);

    // --- 3-source cone emission ---
    if (useThreeSourceCone) {
        std::vector<G4ThreeVector> sourcePositions = {
            G4ThreeVector(-8.0 * cm, 3.5 * cm, 8.0 * cm),
            G4ThreeVector(-8.0 * cm, 3.5 * cm, 8.0 * cm + 50 * cm),
            G4ThreeVector(-8.0 * cm, 3.5 * cm, 8.0 * cm - 50 * cm)
        };

        std::vector<G4ThreeVector> moduleCenters = {
            G4ThreeVector(15 * cm, 0, 45 * cm),
            G4ThreeVector(23 * cm, 0, 45 * cm),
            G4ThreeVector(15 * cm, 0, -45 * cm),
            G4ThreeVector(23 * cm, 0, -45 * cm)
        };

        G4ThreeVector avgModuleCenter(0, 0, 0);
        for (const auto& module : moduleCenters) {
            avgModuleCenter += module;
        }
        avgModuleCenter /= moduleCenters.size();

        G4double coneHalfAngle = 70.0 * deg;

        for (const auto& sourcePos : sourcePositions) {
            fParticleGun->SetParticlePosition(sourcePos);

            // Calculate the cone axis (direction toward the average module center)
            G4ThreeVector coneAxis = (avgModuleCenter - sourcePos).unit();

            // Generate a random direction within the cone
            G4double cosTheta = std::cos(coneHalfAngle);
            G4double randomCosTheta = cosTheta + (1 - cosTheta) * G4UniformRand();
            G4double sinTheta = std::sqrt(1 - randomCosTheta * randomCosTheta);
            G4double phi = 2 * M_PI * G4UniformRand();
            G4ThreeVector randomDirection(
                sinTheta * std::cos(phi),
                sinTheta * std::sin(phi),
                randomCosTheta);

            // Rotate the random direction to align with the cone axis
            G4ThreeVector finalDirection = randomDirection.rotateUz(coneAxis);

            // Set the particle momentum direction
            fParticleGun->SetParticleMomentumDirection(finalDirection);

            // Set the particle energy
            fParticleGun->SetParticleEnergy(240 * MeV);

            // Generate the primary vertex
            fParticleGun->GeneratePrimaryVertex(anEvent);
        }
    }

    // --- Single source, +x direction ---
    if (useSingleSourceX) {
        G4ThreeVector sourcePos(0, 0, 0); // or any desired position
        fParticleGun->SetParticlePosition(sourcePos);
        fParticleGun->SetParticleMomentumDirection(G4ThreeVector(1, 0, 0)); // +x direction
        fParticleGun->SetParticleEnergy(240 * MeV);
        fParticleGun->GeneratePrimaryVertex(anEvent);
    }

    // --- Single source, isotropic emission ---
    if (useSingleSourceIsotropic) {
        G4ThreeVector sourcePos(0, 0, 0); // or any desired position
        fParticleGun->SetParticlePosition(sourcePos);

        G4double cosTheta = 2 * G4UniformRand() - 1;
        G4double sinTheta = std::sqrt(1 - cosTheta * cosTheta);
        G4double phi = 2 * M_PI * G4UniformRand();
        G4ThreeVector direction(sinTheta * std::cos(phi),
                                sinTheta * std::sin(phi),
                                cosTheta);

        fParticleGun->SetParticleMomentumDirection(direction);
        fParticleGun->SetParticleEnergy(240 * MeV);
        fParticleGun->GeneratePrimaryVertex(anEvent);
    }

    // --- 3-source box, isotropic emission ---
    if (useMoireSource) {
        std::vector<G4ThreeVector> sourcePositions = {
            G4ThreeVector(-8.0 * cm, 3.5 * cm, 8.0 * cm),
            G4ThreeVector(-8.0 * cm, 3.5 * cm, 8.0 * cm + 50 * cm),
            G4ThreeVector(-8.0 * cm, 3.5 * cm, 8.0 * cm - 50 * cm)
        };

        G4double boxX = 7.0 * cm;
        G4double boxY = 7.0 * cm;
        G4double boxZ = 250.0 * micrometer;

        for (const auto& sourceCenter : sourcePositions) {
            // Random position within the box centered at sourceCenter
            G4double rx = (G4UniformRand() - 0.5) * boxX;
            G4double ry = (G4UniformRand() - 0.5) * boxY;
            G4double rz = (G4UniformRand() - 0.5) * boxZ;
            G4ThreeVector sourcePos = sourceCenter + G4ThreeVector(rx, ry, rz);

            fParticleGun->SetParticlePosition(sourcePos);

            // Isotropic direction
            G4double cosTheta = 2 * G4UniformRand() - 1;
            G4double sinTheta = std::sqrt(1 - cosTheta * cosTheta);
            G4double phi = 2 * M_PI * G4UniformRand();
            G4ThreeVector direction(
                sinTheta * std::cos(phi),
                sinTheta * std::sin(phi),
                cosTheta);

            fParticleGun->SetParticleMomentumDirection(direction);
            fParticleGun->SetParticleEnergy(240 * MeV);
            fParticleGun->GeneratePrimaryVertex(anEvent);
        }
    }
}